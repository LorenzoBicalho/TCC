# Protocolo de Comunica√ß√£o Cliente-Servidor para Transmiss√£o de Pesos de Rede Neural

Este documento descreve um protocolo bin√°rio m√≠nimo para comunica√ß√£o entre um cliente (eventualmente uma FPGA) e um servidor. A comunica√ß√£o √© bidirecional e permite a transmiss√£o eficiente de vetores de pesos de redes neurais (float32).

## üì° Vis√£o Geral

- Protocolo: TCP/IP (recomendado para confiabilidade e ordem)
- Tipo de dados: bin√°rio puro
- Formato dos dados: `float32` (4 bytes por peso)
- Quantidade fixa de pesos: 190
- Comunica√ß√£o: **bidirecional** e ass√≠ncrona (qualquer lado pode enviar a qualquer momento)

---

## üì¶ Estrutura do Pacote

Cada mensagem enviada segue o seguinte layout bin√°rio:

| Campo                | Tamanho (bytes) | Tipo        | Descri√ß√£o                                                      |
|---------------------|-----------------|-------------|-----------------------------------------------------------------|
| Magic Header        | 2               | uint16      | Valor fixo `0xABCD` para marcar o in√≠cio de um pacote           |
| Opcode              | 1               | uint8       | C√≥digo da opera√ß√£o (veja tabela de opcodes abaixo)             |
| Quantidade de Pesos | 2               | uint16      | N√∫mero de pesos enviados (geralmente 190)                      |
| Dados               | 4 √ó N           | float32[N]  | Vetor de pesos de ponto flutuante de 32 bits                   |

### ‚úÖ Exemplo t√≠pico:
- 190 pesos de float32 = 190 √ó 4 = 760 bytes
- Total do pacote = 2 + 1 + 2 + 760 = **765 bytes**

---

## üßæ Tabela de Opcodes

| Opcode | Significado              |
|--------|--------------------------|
| 0x01   | Envio de pesos           |
| 0x02   | Resposta/Ack             |
| 0x03   | Erro ou pacote inv√°lido  |
| 0x04   | Solicita envio de pesos  |
| 0x05   | Envio de metricas        |



Opcodes adicionais podem ser definidos no futuro conforme necess√°rio.

---

## üß† Considera√ß√µes T√©cnicas

- **Endianess**: todos os campos devem usar **little-endian**  
- **Conex√£o**: TCP persistente (o socket permanece aberto para m√∫ltiplas trocas)  
- **Valida√ß√£o**: o campo Magic Header (`0xABCD`) √© usado para garantir que os pacotes est√£o bem formados  
- **Threading/S√≠ncrono**: para suportar envio e recebimento arbitr√°rio, cada lado deve ser capaz de **ler e escrever simultaneamente**

---

## üí¨ Fluxo de Comunica√ß√£o

### Exemplo 1: FPGA envia pesos
1. FPGA cria pacote com opcode `0x01`, 190 pesos
2. Servidor recebe, valida e armazena
3. Servidor envia resposta opcional com opcode `0x02`

### Exemplo 2: Servidor envia novos pesos
1. Servidor envia pacote `0x01`, com pesos atualizados
2. FPGA recebe e aplica
3. FPGA responde com `0x02` ou ignora se for unidirecional

---

## üîê Seguran√ßa e Integridade (futuro)

- Checksum/CRC para verifica√ß√£o de integridade (n√£o incluso nesta vers√£o)
- Autentica√ß√£o/criptografia se necess√°rio (TLS, chaves p√∫blicas etc)

---

## üß™ Testes Locais

Antes da integra√ß√£o com a FPGA, recomenda-se:

- Implementar cliente de testes em Python (simula a FPGA)
- Implementar servidor TCP em Python
- Enviar/receber pacotes conforme estrutura descrita
- Validar consist√™ncia dos dados recebidos

---

## üìé Anexos

### Estrutura em Python com `struct`:

```python
import struct

# Definindo a estrutura
HEADER_FORMAT = "<H B H"  # Magic (2 bytes), Opcode (1), Quantidade (2)
HEADER_SIZE = struct.calcsize(HEADER_FORMAT)

# Criando pacote com 190 pesos
magic = 0xABCD
opcode = 0x01
qtd_pesos = 190
pesos = [0.1] * 190  # exemplo

header = struct.pack(HEADER_FORMAT, magic, opcode, qtd_pesos)
body = struct.pack("<" + "f" * qtd_pesos, *pesos)
packet = header + body
